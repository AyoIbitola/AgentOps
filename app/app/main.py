from fastapi import FastAPI, Request , Header , HTTPException
from typing import Any, Dict
import os, json, time, uuid, asyncio , hmac , hashlib
import httpx
import boto3
from boto3.dynamodb.conditions import Key
import google.generativeai as genai
import aioboto3
from decimal import Decimal

genai.configure(api_key=os.getenv("GEMINI_API_KEY"))

app = FastAPI()


DDB_TABLE = os.getenv("TIMELINE_TABLE", "")
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY", "")

ECS_CLUSTER_NAME = os.getenv("ECS_CLUSTER_NAME")

_ddb = boto3.resource("dynamodb")
_table = _ddb.Table(DDB_TABLE) if DDB_TABLE else None
ecs_client = boto3.client("ecs")
ses_client = boto3.client("ses", region_name=os.getenv("AWS_REGION", "us-east-2"))

SLACK_BOT_TOKEN = os.getenv("SLACK_BOT_TOKEN", "")
SLACK_SIGNING_SECRET = os.getenv("SLACK_SIGNING_SECRET", "") 
JIRA_URL = os.getenv("JIRA_URL", "")
JIRA_USER = os.getenv("JIRA_USER", "")
JIRA_TOKEN = os.getenv("JIRA_TOKEN", "")
SES_SENDER = os.getenv("SES_SENDER", "")
EMAIL_RECIPIENT = os.getenv("EMAIL_RECIPIENT", "")

class DecimalEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, Decimal):
            return int(obj) if obj % 1 == 0 else float(obj)
        return super().default(obj)

def now_ms() -> int:
    return int(time.time() * 1000)

def new_incident_id() -> str:
    return str(uuid.uuid4())

def record_timeline(incident_id: str, action: str, data: Dict[str, Any]):
    if not _table:
        print("[timeline] DDB table not configured; skipping write")
        return
    item = {
        "incident_id": incident_id,
        "ts": now_ms(),
        "action": action,
        "data": data,
    }
    try:
        _table.put_item(Item=item)
        print(f"[timeline] wrote: {json.dumps(item, cls=DecimalEncoder)}")
    except Exception as e:
        print(f"[timeline ERROR] Failed to record timeline: {e}")

def get_timeline( incident_id: str ):
    if not _table:
        return []
    try:
        resp = _table.query(
            KeyConditionExpression = Key("incident_id").eq(incident_id),
            ScanIndexForward = True
        )
        return resp.get("Items",[])
    except Exception as e :
        print(f"[timeline ERROR] {e}")
        return [ ]
def format_timeline_for_slack(incident_id: str, items: list) -> str:
    if not items:
        return f"No timeline found for incident {incident_id}"
    lines = [f"*ðŸ“œ Timeline for incident `{incident_id}`*"]
    for it in items:
        ts = time.strftime("%H:%M:%S", time.localtime(float(it["ts"]) / 1000))
        action = it.get("action")
        data = it.get("data", {})
        data_json = json.dumps(data, cls=DecimalEncoder)
        short = data_json[:60] + "..." if len(data_json) > 60 else data_json
        lines.append(f"- [{ts}] *{action}* â†’ `{short}`")
    return "\n".join(lines)
def _build_email_html(
    subject: str,
    message: str,
    incident_id: str,
    detail: Dict[str, Any],
    ai: Dict[str, Any],
    timeline_items: list,
    limit: int = 8,
) -> str:
    svc = detail.get("service_name") or "unknown"
    cluster = detail.get("cluster_name") or "unknown"
    summary = detail.get("summary") or "(no summary)"
    decision = ai.get("decision")
    action = ai.get("action")

    
    items = timeline_items[-limit:] if timeline_items else []
    li_html = []
    for it in items:
        ts = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(float(it.get("ts", 0))/ 1000))
        act = it.get("action", "unknown")
        data = it.get("data", {})
        short = json.dumps(data, separators=(",", ":"), cls=DecimalEncoder)
        if len(short) > 120:
            short = short[:120] + "â€¦"
        li_html.append(f"<li><b>{ts}</b> â€” <code>{act}</code> â€” <span>{short}</span></li>")

    timeline_html = (
        "<p><i>No timeline entries yet.</i></p>"
        if not li_html else f"<ul>{''.join(li_html)}</ul>"
    )

    return f"""\
<!DOCTYPE html>
<html>
  <body style="font-family: Arial, sans-serif; line-height: 1.45;">
    <h2>{subject}</h2>
    <p>{message}</p>

    <h3>Incident Summary</h3>
    <ul>
      <li><b>Incident ID:</b> {incident_id}</li>
      <li><b>Decision:</b> {decision}</li>
      <li><b>Action:</b> {action}</li>
      <li><b>Service:</b> {svc}</li>
      <li><b>Cluster:</b> {cluster}</li>
      <li><b>Summary:</b> {summary}</li>
    </ul>

    <h3>Recent Timeline (last {limit})</h3>
    {timeline_html}

    <p style="color:#666; font-size:12px; margin-top:24px;">
      This email was generated by the Incident Agent.
    </p>
  </body>
</html>
"""


async def send_email(
    subject: str,
    body: str,
    incident_id: str = None,
    detail: dict = None,
    ai: dict = None,
    timeline_limit: int = 8
):
    if not SES_SENDER or not EMAIL_RECIPIENT:
        
        print(f"[EMAIL STUB]\nSUBJECT: {subject}\nBODY: {body[:300]}...")
        return

    try:
        items = get_timeline(incident_id)
        html_body = _build_email_html(
            subject=subject,
            message=body,
            incident_id=incident_id,
            detail=detail,
            ai=ai,
            timeline_items=items,
            limit=timeline_limit,
        )

        
        text_lines = [
            subject,
            "",
            body,
            "",
            f"Incident ID: {incident_id}",
            f"Decision: {ai.get('decision')}",
            f"Action: {ai.get('action')}",
            f"Service: {detail.get('service_name')}",
            f"Cluster: {detail.get('cluster_name')}",
            f"Summary: {detail.get('summary')}",
            "",
            "Timeline (last few):"
        ]
        for it in items[-timeline_limit:]:
            ts = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(float(it.get("ts", 0)) / 1000))
            text_lines.append(f"- {ts} :: {it.get('action')} :: {json.dumps(it.get('data', {}), cls=DecimalEncoder)[:100]}")

        text_body = "\n".join(text_lines)

        
        ses_client.send_email(
            Source=SES_SENDER,
            Destination={"ToAddresses": [EMAIL_RECIPIENT]},
            Message={
                "Subject": {"Data": subject, "Charset": "UTF-8"},
                "Body": {
                    "Text": {"Data": text_body, "Charset": "UTF-8"},
                    "Html": {"Data": html_body, "Charset": "UTF-8"},
                },
            },
        )
    except Exception as e:
        print(f"[SES ERROR] {e}")


async def send_slack(
    message: str,
    incident_id: str = None,
    channel: str = None,
    service_name: str = None,
    cluster_name: str = None
):
    if not SLACK_BOT_TOKEN:
        print(f"[SLACK STUB] {message}")
        return

    url = "https://slack.com/api/chat.postMessage"
    headers = {
        "Authorization": f"Bearer {SLACK_BOT_TOKEN}",
        "Content-Type": "application/json"
    }

    payload = {"channel": channel or "#incidents" , "text": message}

    if incident_id:
        payload["blocks"] = [
            {"type": "section", "text": {"type": "mrkdwn", "text": message}},
            {"type": "actions", "elements": [
                {"type": "button", "text": {"type": "plain_text", "text": "ðŸ”„ Restart Service"},
                 "value": json.dumps({
                     "incident_id": incident_id,
                     "action": "restart_service",
                     "service_name": service_name,
                     "cluster_name": cluster_name 
                 }, cls=DecimalEncoder)},
                {"type": "button", "text": {"type": "plain_text", "text": "ðŸ“œ View Timeline"},
                 "value": json.dumps({"incident_id": incident_id, "action": "view_timeline"}, cls=DecimalEncoder)},
                {"type": "button", "text": {"type": "plain_text", "text": "âœ… Acknowledge"},
                 "value": json.dumps({"incident_id": incident_id, "action": "ack"}, cls=DecimalEncoder)}
            ]}
        ]

    async with httpx.AsyncClient() as client:
        await client.post(url, headers=headers, json=payload)

async def create_jira_ticket(title: str, description: str):
    if not JIRA_URL or not JIRA_USER or not JIRA_TOKEN:
        print(f"[JIRA STUB] {title} :: {description[:200]}")
        return
    try: 
        async with httpx.AsyncClient() as client:
            auth = (JIRA_USER, JIRA_TOKEN)
            payload = {
                "fields": {
                    "project": {"key": "SCRUM"},
                    "summary": title,
                    "description": description,
                    "issuetype": {"name": "Bug"},
               }
            }
            await client.post(f"{JIRA_URL}/rest/api/2/issue",auth=auth, json=payload)
    except Exception as e :
        print(f"[JIRA ERROR] {e}")

async def restart_service(service_name: str, cluster_name: str = None):
    cluster_name = cluster_name or ECS_CLUSTER_NAME
    if not cluster_name or not service_name:
        return f"Cannot restart service; missing cluster or service name"

    try:
        resp = ecs_client.describe_services(cluster=cluster_name, services=[service_name])
        services = resp.get("services", [])
        if not services or services[0]["status"] == "INACTIVE":
            return f"Service {service_name} not found in cluster {cluster_name}"
    except Exception as e:
        return f"Error validating service: {e}"

    print(f"[ACTION] Restarting ECS service {service_name} in cluster {cluster_name}...")
    try:
        ecs_client.update_service(
            cluster=cluster_name,
            service=service_name,
            forceNewDeployment=True
        )
        return f"ECS service {service_name} restarted successfully"
    except Exception as e:
        return f"Failed to restart ECS service {service_name}: {e}"

async def notify_team(msg: str, incident_id: str, detail: dict, ai_result: dict):
    await send_slack(msg, incident_id=incident_id, service_name=detail.get("service_name"), cluster_name=detail.get("cluster_name"))

    
    await send_email(
        subject=f"[INCIDENT] {detail.get('summary', incident_id)}",
        body=msg,
        incident_id=incident_id,
        detail=detail,
        ai=ai_result,
        timeline_limit=8
    )
    return "Team notified"


async def ignore_action():
    return "Ignored"


ACTION_MAP = {
    "restart_service": restart_service,
    "notify_team": notify_team,
    "ignore": ignore_action
}


def normalize_eventbridge_event(event: Dict[str, Any]) -> Dict[str, Any]:
    detail = event.get("detail", {})
    service_name = None
    cluster_name = None

    dimensions = detail.get("Trigger", {}).get("Dimensions", [])
    for dim in dimensions:
        if dim.get("name") == "ServiceName":
            service_name = dim.get("value")
        if dim.get("name") == "ClusterName":
            cluster_name = dim.get("value")

    if not service_name and "resources" in event:
        for res in event["resources"]:
            if res.startswith("arn:aws:ecs:"):
                parts = res.split(":")[-1].split("/")
                if len(parts) == 3:
                    _, cluster_from_arn, service_from_arn = parts
                    cluster_name = cluster_name or cluster_from_arn
                    service_name = service_name or service_from_arn

    service_name = service_name or detail.get("service_name") or "my-service"
    cluster_name = cluster_name or detail.get("cluster_name") or ECS_CLUSTER_NAME

    normalized = {**detail, "service_name": service_name, "cluster_name": cluster_name}
    return normalized


async def ai_decide_action(detail: dict, max_retries: int = 3, backoff: float = 1.0) -> dict:
    if not os.getenv("GEMINI_API_KEY"):
        return {"decision": "ESCALATE", "action": "ignore", "message": "AI unavailable"}

    text = json.dumps(detail, separators=(",", ":"), ensure_ascii=False, cls=DecimalEncoder)
    if len(text) > 6000:
        text = text[:6000] + " ..."

    prompt = f"""
    You are an autonomous incident response agent.  

    Task:  
    Analyze the given incident details and return only JSON with the following structure:  

    {{
      "decision": "SAFE" or "ESCALATE",
      "action": "restart_service" | "notify_team" | "ignore",
      "message": "Concise human-readable summary (<=200 chars)"
    }}

    Rules:  
    - "SAFE" means no critical action needed.  
    - "ESCALATE" means human/team intervention required.  
    - Only one action is allowed: "restart_service", "notify_team", or "ignore".  
    - Message must clearly explain incident, affected service, and action taken. 
    - If unsure choose ESCALATE 
    - Do not return anything outside the JSON.  

    Example responses:  
    {{"decision": "ESCALATE", "action": "restart_service", "message": "  Service 'web' in cluster 'test-cluster' reported 5 errors, restarting automatically."}}  
    {{"decision": "SAFE", "action": "ignore", "message": "Routine log: all systems normal."}}  

    Incident details (JSON):  
    ```  
    {text}  
    ```  
    """

    model = genai.GenerativeModel("gemini-1.5-flash")

    attempt = 0
    while attempt < max_retries:
        try:
            response = model.generate_content(
                prompt,
                generation_config={
                    "temperature": 0.2,
                    "max_output_tokens": 500,
                    "response_mime_type": "application/json" 
                }
            )

            
            text_resp = response.text.strip()

            try:
                result = json.loads(text_resp)
                if not all(k in result for k in ("decision", "action", "message")):
                    raise ValueError("Missing required fields in AI response")
            except Exception:
                result = {
                    "decision": "ESCALATE",
                    "action": "ignore",
                    "message": "AI returned invalid response"
                }

            return result

        except Exception as e:
            attempt += 1
            print(f"[ai_decide_action] attempt {attempt} failed: {e}")
            if attempt < max_retries:
                await asyncio.sleep(backoff * attempt)
            else:
                return {
                    "decision": "ESCALATE",
                    "action": "ignore",
                    "message": "AI error after retries"
                }
async def process_incident(detail: Dict[str, Any], incident_id: str, source: str):
    record_timeline(incident_id, f"received_{source}", {"detail": detail})

    ai_result = await ai_decide_action(detail)
    record_timeline(incident_id, "ai_assessment", ai_result)

    action_name = ai_result.get("action", "ignore")
    action_fn = ACTION_MAP.get(action_name, ignore_action)

    service_name = detail.get("service_name")
    cluster_name = detail.get("cluster_name")

    
    if action_name == "restart_service" and service_name:
        action_result = await action_fn(service_name, cluster_name)
    elif action_name == "notify_team":
        action_result = await action_fn(
        ai_result.get("message", f"Incident {incident_id} detected"),
        incident_id,
        detail,
        ai_result
    )
    else:
        action_result = await action_fn()

    record_timeline(
        incident_id,
        "action_executed",
        {"action": action_name, "result": action_result}
    )

    
    msg = ai_result.get("message", f"Incident {incident_id} processed")

    
    if action_name != "ignore":
        
        await send_slack(
            msg,
            incident_id=incident_id,
            service_name=service_name,
            cluster_name=cluster_name
        )

        
        await create_jira_ticket(
            f"[INCIDENT] {detail.get('summary', incident_id)}",
            msg
        )

        
        await send_email(
            subject=f"[INCIDENT] {detail.get('summary', incident_id)}",
            body=msg,
            incident_id=incident_id,
            detail=detail,
            ai=ai_result,
            timeline_limit=8,
        )

    record_timeline(
        incident_id,
        "notified_channels",
        {
            "slack": action_name != "ignore",
            "jira": action_name != "ignore",
            "email": action_name != "ignore",
            "source": source
        }
    )

    return ai_result





@app.get("/")
def root():
    return {"message": "AI agent is live ðŸš€ðŸ¤–"}

@app.get("/health")
def health():
    return {"status": "ok"}

@app.post("/alert")
async def alert(request: Request):
    payload = await request.json()
    incident_id = payload.get("incident_id") or new_incident_id()
    detail = normalize_eventbridge_event(payload)
    ai_result = await process_incident(detail, incident_id, source="eventbridge")
    return {"status": "incident handled", "incident_id": incident_id, "ai": ai_result}

@app.post("/slack/actions")
async def slack_actions(
    request: Request,
    x_slack_signature: str = Header(None),
    x_slack_request_timestamp: str = Header(None)
):
    
    if not SLACK_SIGNING_SECRET:
        raise HTTPException(status_code=500, detail="Slack signing secret not configured")

    raw_body = await request.body()
    timestamp = x_slack_request_timestamp
    sig_basestring = f"v0:{timestamp}:{raw_body.decode()}"
    my_sig = "v0=" + hmac.new(SLACK_SIGNING_SECRET.encode(), sig_basestring.encode(), hashlib.sha256).hexdigest()

    
    if not hmac.compare_digest(my_sig, x_slack_signature):
        raise HTTPException(status_code=403, detail="Invalid Slack signature")

    
    if abs(time.time() - int(timestamp)) > 60 * 5:
        raise HTTPException(status_code=403, detail="Request too old")

   
    form = await request.form()
    payload = json.loads(form["payload"])
    user = payload["user"]["username"]
    action = payload["actions"][0]
    value = json.loads(action["value"])
    incident_id, action_name = value["incident_id"], value["action"]

    
    if action_name == "restart_service":
        service_name = value.get("service_name", "my-service")
        cluster_name = value.get("cluster_name", ECS_CLUSTER_NAME)
        result = await restart_service(service_name, cluster_name)
        record_timeline(incident_id, "slack_restart", {"by": user, "result": result})
        await send_slack(f"ðŸ”„ {user} restarted service `{service_name}` in `{cluster_name}` for incident {incident_id}", incident_id, channel=payload["channel"]["id"])

    elif action_name == "view_timeline":
        items = get_timeline(incident_id)
        msg = format_timeline_for_slack(incident_id, items)
        await send_slack(msg, incident_id, channel=payload["channel"]["id"])

    elif action_name == "ack":
        record_timeline(incident_id, "slack_ack", {"by": user})
        await send_slack(f"âœ… {user} acknowledged incident {incident_id}", incident_id, channel=payload["channel"]["id"])

    return {"ok": True}